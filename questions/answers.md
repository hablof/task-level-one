## 1. Какой самый эффективный способ конкатенации строк?

Самым эффективным методом конкатенации в обоих случаях является использование strings.Builder с предварительным выделением памяти.

Однако заметим, что в случае фиксированного количества строк, прямая конкатенация совсем незначительно уступает как в быстродействии, так и в использовании памяти

## 2. Что такое интерфейсы, как они применяются в Go?

### Что такое интерфейс?

Интерфейсы в GO это тип, определяющий множество типов.

Интерфейс определяется набором сигнатур методов (контрактом), которые должны имется у типа, чтобы он "выполнил" интерфейс

Переменная интерфесного типа может хранить любой тип данных выполняющий конкретный интерфейс.

### Как они применяются?

Теоретически:
С помощью интерфейсов реализуется столп ООП -- Абстракция. (использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе). То есть интерфейс -- абстрактный тип данных

Практически:
1) Используются для уменьшения связанности между пакетами приложения
2) Используются для генерации мок-объектов

### Как устроены?

Интерфейс -- структура с двумя полями
1) тип объекта (реальный, не интерфейсный)
2) указатель на объект


## 3. Чем отличаются RWMutex от Mutex?

RWMutex, в отличии от Mutex, позволяет производить конурентное чтение, но и работает медленнее (потому что сложнее устроен).
Его целесообразно использовать, когда количество чтений знчительно превышает  количество записей

## 4. Чем отличаются буферизированные и не буферизированные каналы?

Если из канала никто не читает:
* запись в небуферезированный канал блокирует горутину
* запись в буферезированный канал не блокирует горутину, если буфер канала не заполнен

## 5. Какой размер у структуры struct{}{}?

fmt.Printf("unsafe.Sizeof(struct{}{}): %v\n", unsafe.Sizeof(struct{}{}))

-> unsafe.Sizeof(struct{}{}): 0

## 6. Есть ли в Go перегрузка методов или операторов?

Нет

## 7. В какой последовательности будут выведены элементы map[int]int?

При выводе с помощью пакета fmt путём вывода переменной мапы, вывод будет отсортирован по ключу.

Итерирование по мапе циклом `for key, value := range m {}` будет случайным

## 8. В чем разница make и new?

* new(Т) аллоцирует память под zero-value указанного типа возвращает указатель на значение
* make(Т) может быть использован только для создания слайса, мапы и канала. Возвращает инициализированный объект. Это единственный способ создать канал.

## 9. Сколько существует способов задать переменную типа slice или map?

Именно _переменную_ можно задать двумя способами: через ключевое слово `var` и с помощью оператора `:=`.

А получить переменную slice _готовую к работе_ можно *тремя* способами: new, make и указав конкретный слайс с помощью фигурных скобок.

А получить переменную map _готовую к работе_ можно  только *двумя* способами: make и указав конкретную mapс с помощью фигурных скобок. 

## 10. Что выведет данная программа и почему?
```
func update(p *int) {
    b := 2
    p = &b
}
func main() {
    var (
        a = 1
        p = &a
    )   
fmt.Println(*p)
update(p)
fmt.Println(*p)
}
```
Выведет 1 1

Потому что переменные функцию путём копирования значения.

## 11. Что выведет данная программа и почему?
```
func main() {
    wg := sync.WaitGroup{}
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(wg sync.WaitGroup, i int) {
            fmt.Println(i)
            wg.Done()
        }(wg, i)
    }
wg.Wait()
fmt.Println("exit")
}
```
01234 случайном порядке и зависнет
Потому что переменные функцию путём копирования значения.

wg.Done() будет применятся не к тому же объекту WaitGroup, к которому применяется wg.Add(1)


## 12. Что выведет данная программа и почему?
```
func main() {
    n := 0
    if true {
        n := 1
        n++
    }
    fmt.Println(n)
}
```
0 потому что внутри области видимости обозначенной фигурными скобками, переменная перекрыта(затенена) переменной с тем же названием.

## 13. Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
    v[0] = 100
    v = append(v, b)
}
func main() {
    var a = []int8{1, 2, 3, 4, 5}
    someAction(a, 6)
    fmt.Println(a)
}
```
```
[100 2 3 4 5]
```
слайс - это структура из трёх полей
1) ссылка на нижележащий массив
2) количество элементов (len)
3) ёмкость cap (длина нижележащего массива)

и он тоже передаётся в функцию копированием

внутри функции меняется элемент массива(!), на который ссылается слайс
и увеличивается поле len

снаружи функции поле len осталось неизменным

## 14. Что выведет данная программа и почему?
```
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```

```
[b b a][a a]
```

Внутри анонимной функции добавление элемента вызвало переалокацию нижележащего массива для слайса slice, в нём поменялись первый два элемента

"Внешний" слайс ничего не знает про переаллокацию и по прежнему ссылается на массив [a a]